#'Gibbs sampler used to estimate the posterior distribution of parameters in HDP model for metabolite effects
#'
#' @param data A list contains the input. It can be generated by function 'prepareData'.
#' @param Iter A integer specifying the total number of iterations.
#' @param record A integer specifying the iteration at which the function starts recording Gibbs samples.
#'
#' @return A list containing the Gibbs samples of each factor.
#' "Mean": a number of Gibbs samples by number of subpathways matrix, whose entries represent the posterior means of subpathways;
#' "SD": a number of Gibbs samples by number of subpathways matrix, whose entries represent the posterior sd of subpathways;
#' "Outlier": a number of Gibbs samples by number of metabolites matrix, whose entries indicate if the metabolite is an outlier (1) or not (0);
#' "L.post.mean": a number of Gibbs samples by number of metabolites matrix, whose entries records the posterior mean of each metabolite;
#' "L.post.sd": a number of Gibbs samples by number of metabolites matrix, whose entries records the posterior sds of each metabolite ;
#' "lfsr": a number of Gibbs samples by number of metabolites matrix, whose entries records the local false sign rate of each metabolite ;
#' "W": a number of subpathways by number of subpathways matrix, with it (i,j)th entry represents the probability that subpathway i and j share the same parameter;
#' "p.singleton": a length number of subpathways vector, recording the probability that each subpathway do not share parameter with other subpathways;
#' "P.post.theta": a length number of Iter vector, recording the log joint posterior probability of parameters at each iteration.
#' @export
HDP_Gibbs <- function(data,Iter=1500,record=501){
  IDs <- data$IDs;K <- ncol(data$L)

  n.metabolite <- 5
  IDs.known <- IDs[IDs$SUB_PATHWAY!="Unknown",]
  t <- table(IDs.known$SUB_PATHWAY  )
  subp.big <- names(t)[t>=n.metabolite]
  IDs.big <- IDs[IDs$SUB_PATHWAY %in% subp.big,]
  Results <- list()
  for (k.latent in 1:K) {
    #estimate parameters of var(L)
    var.g <- sapply(1:length(unique(IDs.big$SUB_PATHWAY)), function(i){var(data$L[IDs$SUB_PATHWAY==unique(IDs.big$SUB_PATHWAY)[i],k.latent][abs((data$L[IDs$SUB_PATHWAY==unique(IDs.big$SUB_PATHWAY)[i],k.latent]-mean(data$L[IDs$SUB_PATHWAY==unique(IDs.big$SUB_PATHWAY)[i],k.latent]))/sd(data$L[IDs$SUB_PATHWAY==unique(IDs.big$SUB_PATHWAY)[i],k.latent]))<3])})-
      sapply(1:length(unique(IDs.big$SUB_PATHWAY)), function(i){mean( data$var[[1]][IDs$SUB_PATHWAY==unique(IDs.big$SUB_PATHWAY)[i]][abs((data$L[IDs$SUB_PATHWAY==unique(IDs.big$SUB_PATHWAY)[i],k.latent]-mean(data$L[IDs$SUB_PATHWAY==unique(IDs.big$SUB_PATHWAY)[i],k.latent]))/sd(data$L[IDs$SUB_PATHWAY==unique(IDs.big$SUB_PATHWAY)[i],k.latent]))<3]*data$var$V[k.latent] )})
    var.g <- var.g[var.g>0.01];var.g <- var.g[!is.na(var.g)]
    alpha <- mean(var.g)^2/var(var.g)+2;beta <- (alpha-1)*mean(var.g)
    #set grid for sd(L)
    taus <- sqrt(invgamma::qinvgamma(c(1:20)/21,shape = alpha,rate = beta))#fix quantiles
    p.taus <- invgamma::dinvgamma(x = taus^2,shape = alpha,rate = beta);p.taus <- p.taus/sum(p.taus)
    #initial concentration parameters
    alpha1_mu <- 2;alpha2_mu <- 2
    #hyperparameters for concentration parameters
    alpha1.a <- 5;alpha1.b <- 1;alpha2.a <- 5;alpha2.b <- 1
    #grid for concentration parameters
    alpha.grid <- c(seq(0.1,1,0.1),c(1:15) )
    #hyperparameters for outliers
    p.outlier.alpha <- 1/5;p.outlier.beta <- 999/5
    #initial prob of outliers
    p.outlier <- 0.001
    #initial prob of mean 0 and spike
    p.0 <- 0.1;p.00 <- 0.1
    #upper and lower bounds for outliers
    b.l <- ((range(data$L[,k.latent])-mean(data$L[,k.latent]))*1.25+mean(data$L[,k.latent]))[1];b.u <- ((range(data$L[,k.latent])-mean(data$L[,k.latent]))*1.25+mean(data$L[,k.latent]))[2]
    #set grid for parameters in horseshoe prior
    w <- stats::qcauchy(p = c(0.6,0.7,0.8,0.9,0.95),location = 0,scale = 1)
    p.w <- stats::dcauchy(x = qcauchy(p = c(0.6,0.7,0.8,0.9,0.95),location = 0,scale = 1),location = 0,scale = 1);p.w <- p.w/sum(p.w)
    #Initialize data container
    pathways <- listOfPathway(data = data$IDs,supname = "SUPER_PATHWAY",subname ="SUB_PATHWAY",L.hat=data$L,var.g = data$var,k=k.latent,a = 1,b = 1,taus = taus)
    J <- length(pathways)
    dishes <- InitDishes()
    restaurants <- InitRestaurants(pathways = pathways)
    clusters <- InitClusters(pathways = pathways)
    M_k <- matrix(data = 0,nrow = J);M_k <- M_k[,-1]#number of tables serving dish k
    num.sub <- length(unique(IDs$SUB_PATHWAY))
    Community <- matrix(data = 0,nrow = num.sub,ncol = num.sub)
    Is.singleton <- rep(0,length(unique(data$IDs$SUB_PATHWAY)))
    #clusterAssignments <- array(data = NA,dim = c(num.sub,num.sub,Iter-record+1))
    Mu.g <- matrix(nrow = Iter-record+1,ncol = num.sub)
    Sigma.g <- matrix(nrow = Iter-record+1,ncol =num.sub)
    Post.L.mean <- matrix(nrow = Iter-record+1,ncol = nrow(data$IDs))
    Post.L.sd <- matrix(nrow = Iter-record+1,ncol = nrow(data$IDs))
    Is.outlier <- matrix(nrow = Iter,ncol = nrow(data$IDs))
    LFSR <- matrix(nrow = Iter-record+1,ncol = nrow(IDs))
    num.clusters <- vector();P.post.theta <- vector()

    #run Gibbs sampler
    for (iter in 1:Iter) {
      for (j in 1:J) {
        for (g in 1:length(pathways[[j]])) {
          for (m in sample(x = c(1:pathways[[j]][[g]]$Mg),size = pathways[[j]][[g]]$Mg,replace = FALSE)) {
            #assign m to a cluster with the majority or the cluster of outliers
            m.is.outlier <- is.outlier(pathways = pathways,j = j,g = g,m = m,p.outlier = p.outlier,alpha1_mu = alpha1_mu,alpha2_mu = alpha2_mu,clusters = clusters,restaurants = restaurants,dishes = dishes,M_k = M_k,N_t = N_t,N_c = N_c,taus = taus,p.taus = p.taus,p.00 = p.00,p.0 = p.0,b.l = b.l,b.u = b.u,w=w,p.w=p.w)
            pathways[[j]][[g]]$z[m] <- m.is.outlier
            pathways[[j]][[g]]$c[m] <- 1-m.is.outlier
            Is.outlier[iter,pathways[[j]][[g]]$indices[m]] <- m.is.outlier
            pathways[[j]][[g]]$t[m] <- 0;pathways[[j]][[g]]$k[m] <- 0
            #if m is not an outlier
            if(!m.is.outlier){
              c.m <- 1
              if( !(c.m%in%clusters[[j]][[g]][,1]) ){
                #assign table for cluster c
                t_c <- sample_t_c(pathways = pathways,clusters=clusters,j = j,g = g,c.m = c.m,alpha1_mu = alpha1_mu,alpha2_mu = alpha2_mu,restaurants = restaurants,dishes = dishes,M_k = M_k,taus = taus,p.taus = p.taus,p.00 = p.00,p.0 = p.0,w = w,p.w = p.w)
                #if t is new
                if(!(t_c%in%restaurants[[j]][,1])){
                  #sample dish for new table
                  k_for_t.new <- kForNewTable4(j = j,dishes = dishes,L = pathways[[j]][[g]]$Lgm.hat[m],var.m = pathways[[j]][[g]]$var.gm[m],taus = taus,p.taus =p.taus,M_k = M_k,alpha1_mu = alpha1_mu,alpha2_mu = alpha2_mu,w = w,p.w = p.w,p.00 = p.00,p.0 = p.0)
                  #if k is new
                  if(!(k_for_t.new%in%dishes[,1])){
                    #sample a new parameter
                    mu.sigma.new <- new.parameter(L = pathways[[j]][[g]]$Lgm.hat[m],var.m = pathways[[j]][[g]]$var.gm[m],taus = taus,p.taus = p.taus,w = w,p.w = p.w,p.00 = p.00,p.0 = p.0)
                    mu_new <- mu.sigma.new$mu;sigma_new <- mu.sigma.new$sigma
                    dishes <- rbind(dishes, c(k_for_t.new,mu_new,sigma_new) )
                  }
                  restaurants[[j]] <- rbind(restaurants[[j]], c(t_c,k_for_t.new,dishes[dishes[,1]==k_for_t.new,2],dishes[dishes[,1]==k_for_t.new,3]) )
                  M_k <- updateM_k(dishes,M_k,j,restaurants)
                }
                clusters[[j]][[g]] <- rbind( clusters[[j]][[g]],c(c.m,t_c,restaurants[[j]][restaurants[[j]][,1]==t_c,2],restaurants[[j]][restaurants[[j]][,1]==t_c,3],restaurants[[j]][restaurants[[j]][,1]==t_c,4]) )
              }
              #update model parameters
              pathways[[j]][[g]]$t[m] <- clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,2]
              pathways[[j]][[g]]$k[m] <- clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,3]
              pathways[[j]][[g]]$mu[m] <- clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,4]
              pathways[[j]][[g]]$sigma_g[m] <- clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,5]
              #remove empty clusters
              clusters.to.remove <- setdiff(clusters[[j]][[g]][,1],pathways[[j]][[g]]$c)
              if(length(clusters.to.remove)>0){
                clusters[[j]][[g]] <- clusters[[j]][[g]][-which(clusters[[j]][[g]][,1] %in%  clusters.to.remove ),]
                if(is.vector(clusters[[j]][[g]])){
                  clusters[[j]][[g]] <- matrix(data = clusters[[j]][[g]],ncol = 5)
                  colnames(clusters[[j]][[g]]) <- c("cluster","table","dish","mu","sigma")
                }
              }
            }
          }
          #remove empty tables
          tables.to.remove <- setdiff(restaurants[[j]][,1],unique(unlist(sapply(clusters[[j]], function(g){g[,2]}))))
          if(length(tables.to.remove)>0){
            restaurants[[j]] <- restaurants[[j]][-which(restaurants[[j]][,1]%in% tables.to.remove),]
            if(is.vector(restaurants[[j]])){
              restaurants[[j]] <- matrix(data = restaurants[[j]],ncol =4)
              colnames(restaurants[[j]]) <- c("table","dish","mu","sigma")
            }
          }
          M_k <- updateM_k(dishes,M_k,j,restaurants)
          #remove unused dishes
          dishes.to.remove <- which(colSums(M_k)==0)
          if(length(dishes.to.remove)>0){
            M_k <- M_k[,-dishes.to.remove]
            dishes <- dishes[-dishes.to.remove,]
            if(is.vector(dishes)){
              dishes <- matrix(data = dishes,ncol = 3)
              colnames(dishes) <- c("k","mu","sigma")
              M_k <- matrix(data = M_k,nrow = J)
              colnames(M_k) <- dishes[,1]
            }
          }
        }
      }

      # update table assignments for clusters
      for (j in 1:J) {
        for (g in 1:length(pathways[[j]])) {
          #j <- 5;g <- 23
          for (c.m in clusters[[j]][[g]][,1]) {
            t_c <- sample_t_c(pathways = pathways,clusters=clusters,j = j,g = g,c.m = c.m,alpha1_mu = alpha1_mu,alpha2_mu = alpha2_mu,restaurants = restaurants,dishes = dishes,M_k = M_k,taus = taus,p.taus = p.taus,p.00 = p.00,p.0 = p.0,w = w,p.w = p.w)
            #t_c <- nextIndix(restaurants[[j]][,1])
            L <- pathways[[j]][[g]]$Lgm.hat[pathways[[j]][[g]]$c==c.m]
            var.m <- pathways[[j]][[g]]$var.gm[pathways[[j]][[g]]$c==c.m]
            #if t is new
            if(!(t_c%in%restaurants[[j]][,1])){
              #sample dish for new table
              k_for_t.new <- kForNewTable4(j = j,dishes = dishes,L = L,var.m = var.m,taus = taus,p.taus =p.taus,M_k = M_k,alpha1_mu = alpha1_mu,alpha2_mu = alpha2_mu,w = w,p.w = p.w,p.00 = p.00,p.0 = p.0)
              #if k is new
              if(!(k_for_t.new%in%dishes[,1])){
                #sample a new parameter
                mu.sigma.new <- new.parameter(L = L,var.m = var.m,taus = taus,p.taus = p.taus,w = w,p.w = p.w,p.00 = p.00,p.0 = p.0)
                mu_new <- mu.sigma.new$mu;sigma_new <- mu.sigma.new$sigma
                dishes <- rbind(dishes, c(k_for_t.new,mu_new,sigma_new) )
              }
              restaurants[[j]] <- rbind(restaurants[[j]], c(t_c,k_for_t.new,dishes[dishes[,1]==k_for_t.new,2],dishes[dishes[,1]==k_for_t.new,3]) )
              M_k <- updateM_k(dishes,M_k,j,restaurants)
            }
            clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,2] <- t_c
            clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,3] <- restaurants[[j]][restaurants[[j]][,1]==t_c,2]
            clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,4] <- restaurants[[j]][restaurants[[j]][,1]==t_c,3]
            clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,5] <- restaurants[[j]][restaurants[[j]][,1]==t_c,4]
            pathways[[j]][[g]]$t[pathways[[j]][[g]]$c==c.m] <- t_c
            pathways[[j]][[g]]$k[pathways[[j]][[g]]$c==c.m] <- clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,3]
            pathways[[j]][[g]]$mu[pathways[[j]][[g]]$c==c.m] <- clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,4]
            pathways[[j]][[g]]$sigma_g[pathways[[j]][[g]]$c==c.m] <- clusters[[j]][[g]][clusters[[j]][[g]][,1]==c.m,5]
          }
          #remove empty tables
          tables.to.remove <- setdiff(restaurants[[j]][,1],unique(unlist(sapply(clusters[[j]], function(g){g[,2]}))))
          if(length(tables.to.remove)>0){
            restaurants[[j]] <- restaurants[[j]][-which(restaurants[[j]][,1]%in% tables.to.remove),]
            if(is.vector(restaurants[[j]])){
              restaurants[[j]] <- matrix(data = restaurants[[j]],ncol =4)
              colnames(restaurants[[j]]) <- c("table","dish","mu","sigma")
            }
          }
          M_k <- updateM_k(dishes,M_k,j,restaurants)
          #remove unused dishes
          dishes.to.remove <- which(colSums(M_k)==0)
          if(length(dishes.to.remove)>0){
            M_k <- M_k[,-dishes.to.remove]
            dishes <- dishes[-dishes.to.remove,]
            if(is.vector(dishes)){
              dishes <- matrix(data = dishes,ncol = 3)
              colnames(dishes) <- c("k","mu","sigma")
              M_k <- matrix(data = M_k,nrow = J)
              colnames(M_k) <- dishes[,1]
            }
          }
        }
      }

      #updata k for t
      for(j in 1:J){
        for (i in 1:nrow(restaurants[[j]])) {
          t <- restaurants[[j]][i,1]
          L <- unlist(sapply(pathways[[j]], function(g){g$Lgm.hat[g$t==t]}))
          var.m <- unlist(sapply(pathways[[j]], function(g){g$var.gm[g$t==t]}))
          k_for_t <- kForNewTable4(j = j,dishes = dishes,L = L,var.m = var.m,taus = taus,p.taus =p.taus,M_k = M_k,alpha1_mu = alpha1_mu,alpha2_mu = alpha2_mu,w = w,p.w = p.w,p.00 = p.00,p.0 = p.0)
          #if k is new
          if(!(k_for_t%in%dishes[,1])){
            #sample a new parameter
            mu.sigma.new <- new.parameter(L = L,var.m = var.m,taus = taus,p.taus = p.taus,w = w,p.w = p.w,p.00 = p.00,p.0 = p.0)
            mu_new <- mu.sigma.new$mu;sigma_new <- mu.sigma.new$sigma
            dishes <- rbind(dishes, c(k_for_t,mu_new,sigma_new) )
          }
          restaurants[[j]][i,2] <- k_for_t
          restaurants[[j]][i,3] <- dishes[dishes[,1]==k_for_t,2]
          restaurants[[j]][i,4] <- dishes[dishes[,1]==k_for_t,3]
          M_k <- updateM_k(dishes,M_k,j,restaurants)
          #update model paremeters
          for (g in 1:length(pathways[[j]])) {
            #g <- 2
            if(sum(clusters[[j]][[g]][,2]==t)>0){
              clusters[[j]][[g]][clusters[[j]][[g]][,2]==t,3] <- k_for_t
              clusters[[j]][[g]][clusters[[j]][[g]][,2]==t,4] <- dishes[dishes[,1]==k_for_t,2]
              clusters[[j]][[g]][clusters[[j]][[g]][,2]==t,5] <- dishes[dishes[,1]==k_for_t,3]
              pathways[[j]][[g]]$k[pathways[[j]][[g]]$t==t] <- k_for_t
              pathways[[j]][[g]]$mu[pathways[[j]][[g]]$t==t] <- dishes[dishes[,1]==k_for_t,2]
              pathways[[j]][[g]]$sigma_g[pathways[[j]][[g]]$t==t] <- dishes[dishes[,1]==k_for_t,3]
            }
          }
        }
      }
      #remove unused dishes
      dishes.to.remove <- which(colSums(M_k)==0)
      if(length(dishes.to.remove)>0){
        M_k <- M_k[,-dishes.to.remove]
        dishes <- dishes[-dishes.to.remove,]
        if(is.vector(dishes)){
          dishes <- matrix(data = dishes,ncol = 3)
          colnames(dishes) <- c("k","mu","sigma")
          M_k <- matrix(data = M_k,nrow = J)
          colnames(M_k) <- dishes[,1]
        }
      }

      if(iter>round(record/2)){
        #update p.outlier
        p.outlier <- (p.outlier.alpha+sum( Is.outlier[iter,] ))/(p.outlier.alpha+p.outlier.beta+ncol(Is.outlier))

        #update concentration parameters using grid
        Tj <- sapply(restaurants, function(j){nrow(j)})
        nj <- sapply(1:J, function(j){sum(sapply(clusters[[j]], function(g){nrow(g)}))})
        num.tabkes <- sum(Tj)
        num.dishes <- nrow(dishes)
        #super
        p.alpha1 <- dgamma(x = alpha.grid,shape = alpha1.a,rate = alpha1.b)*alpha.grid^num.dishes*gamma(alpha.grid)/gamma(alpha.grid+num.tabkes)
        alpha1_mu <- sample(x = alpha.grid,size = 1,prob = p.alpha1)
        #sub
        p.alpha2 <- sapply(1:length(alpha.grid), function(i){dgamma(x = alpha.grid[i],shape = alpha2.a,rate = alpha2.b)*alpha.grid[i]^num.tabkes* prod( gamma(alpha.grid[i])/gamma(alpha.grid[i]+nj) ) })
        alpha2_mu <- sample(x = alpha.grid,size = 1,prob = p.alpha2)

        #update p0 and p00
        num.spike <- 0
        num.mean0 <- 0
        num.path <- 0
        for (j in 1:J) {
          for (g in 1:length(pathways[[j]])) {
            k.g <- unique(pathways[[j]][[g]]$k);k.g <- k.g[k.g!=0]
            if(length(k.g)==1){
              num.path <- num.path + 1
              mu.g <- dishes[dishes[,1]==k.g,2];sigma.g <- dishes[dishes[,1]==k.g,3]
              if(mu.g==0){
                if(sigma.g==0){
                  num.spike <- num.spike+1
                }else{
                  num.mean0 <- num.mean0+1
                }
              }
            }
          }
        }
        p.00 <- rbeta(n = 1,shape1 = 1+num.spike,shape2 = 1+num.path-num.spike)
        p.0 <- rbeta(n = 1,shape1 = 1+num.mean0,shape2 = 1+num.path-num.spike-num.mean0)
      }

      #update mus
      for (k in 1:nrow(dishes)) {
        #k <- 1
        k_mu <- dishes[k,1]
        meta.list <- select.all.metabolites(k_mu,pathways)
        mu.sigma.new <- new.parameter(L = meta.list$L.hat,var.m = meta.list$var.m,taus = taus,p.taus = p.taus,w = w,p.w = p.w,p.00 = p.00,p.0 = p.0)
        dishes[k,2] <- mu.sigma.new$mu;dishes[k,3] <- mu.sigma.new$sigma
      }
      for(j in 1:J){
        for (i in 1:nrow(restaurants[[j]])) {
          restaurants[[j]][i,3] <- dishes[dishes[,1]==restaurants[[j]][i,2],2]
          restaurants[[j]][i,4] <- dishes[dishes[,1]==restaurants[[j]][i,2],3]
        }
        for (g in 1:length(pathways[[j]])) {
          for (c in clusters[[j]][[g]][,1]) {
            #update sigma_c
            k <- clusters[[j]][[g]][clusters[[j]][[g]][,1]==c,3]
            pathways[[j]][[g]]$mu[pathways[[j]][[g]]$c==c] <- dishes[which(dishes[,1]==k),2]
            pathways[[j]][[g]]$sigma_g[pathways[[j]][[g]]$c==c] <- dishes[which(dishes[,1]==k),3]
            clusters[[j]][[g]][clusters[[j]][[g]][,1]==c,4] <- dishes[which(dishes[,1]==k),2]
            clusters[[j]][[g]][clusters[[j]][[g]][,1]==c,5] <- dishes[which(dishes[,1]==k),3]
          }
        }
      }
      #calculate posterior of parameters
      {
        p.theta <- sum(dishes[,3]==0)*log(p.00)+
          sum(log(invgamma::dinvgamma(x = dishes[dishes[,3]!=0,3]^2,shape = alpha,rate = beta)))+
          sum(ifelse(dishes[dishes[,3]!=0,2]==0,log(p.0),sapply(dishes[dishes[,3]!=0,2], function(x){ log(sum( p.w*dnorm(x = x,mean = 0,sd = w) )) })))+
          log(dgamma(x = alpha1_mu,shape = alpha1.a,rate = alpha1.b))+
          log(dgamma(x = alpha2_mu,shape = alpha2.a,rate = alpha2.b))
        p.c.given.theta <- sum(sapply(colSums(M_k), function(x){ sum(log(c(1:x)-1+alpha1_mu)) }))-
          sum(log(c(1:sum(M_k))-1+alpha1_mu))
        p.data.given.c.theta <- 0
        for (j in 1:length(pathways)) {
          t.g <- unlist(sapply(pathways[[j]], function(g){ if(length(unique(g$t[g$t!=0]))>0){unique(g$t[g$t!=0])} }))
          p.c.given.theta <- p.c.given.theta + sum(sapply(table(t.g), function(g)(sum(log(c(1:g)-1+alpha2_mu)))))-sum(log(c(1:sum(table(t.g)))-1+alpha2_mu))
          for (g in 1:length(pathways[[j]])) {
            if(any(pathways[[j]][[g]]$z==0)){
              p.c.given.theta <- p.c.given.theta + sum(log(dnorm(x = pathways[[j]][[g]]$Lgm.hat[pathways[[j]][[g]]$z==0],mean = pathways[[j]][[g]]$mu[pathways[[j]][[g]]$z==0],sd = sqrt( (pathways[[j]][[g]]$sigma_g[pathways[[j]][[g]]$z==0])^2 + pathways[[j]][[g]]$var.gm[pathways[[j]][[g]]$z==0] ))))
            }
          }
        }
        P.post.theta <- c(P.post.theta,p.theta+ p.c.given.theta + p.data.given.c.theta)
      }
      #record outputs
      if(iter>=record){
        num.clusters <- c(num.clusters,nrow(dishes))
        var.gm<- vector()
        k.sub <- vector()
        post.L.mean <- vector()
        post.L.sd <- vector()
        mu.g <- vector()
        sigma.g <- vector()
        for (j in 1:J) {
          for (g in 1:length(pathways[[j]])) {
            k.sub <- c(k.sub,as.numeric(names(which.max(table(pathways[[j]][[g]][["k"]])))))
            if(nrow(clusters[[j]][[g]])==0){
              #print(paste0(j,":",g))
              mu.g[pathways[[j]][[g]]$g] <- mean(pathways[[j]][[g]]$Lgm.hat)
              sigma.g[pathways[[j]][[g]]$g] <- sd(pathways[[j]][[g]]$Lgm.hat)
            }else{
              mu.g[pathways[[j]][[g]]$g] <- clusters[[j]][[g]][1,4]
              sigma.g[pathways[[j]][[g]]$g] <- clusters[[j]][[g]][1,5]
            }

            if(sum(pathways[[j]][[g]]$sigma_g==0)>= pathways[[j]][[g]]$Mg/2){
              pathways[[j]][[g]]$is.spike <- c(pathways[[j]][[g]]$is.spike,1)
              post.L.mean <- c(post.L.mean,rep(0,pathways[[j]][[g]]$Mg)  )
              post.L.sd <- c(post.L.sd,rep(0,pathways[[j]][[g]]$Mg))
            }else{
              pathways[[j]][[g]]$is.spike <- c(pathways[[j]][[g]]$is.spike,0)
              post.var <- ifelse(pathways[[j]][[g]]$sigma_g==0,0,1/(1/pathways[[j]][[g]]$var.gm+1/pathways[[j]][[g]]$sigma_g^2))
              post.mean <- ifelse(pathways[[j]][[g]]$sigma_g==0,0,(pathways[[j]][[g]]$Lgm.hat/pathways[[j]][[g]]$var.gm +pathways[[j]][[g]]$mu/pathways[[j]][[g]]$sigma_g^2   )*post.var)
              post.L.mean <- c(post.L.mean,post.mean  )
              post.L.sd <- c(post.L.sd,sqrt(post.var))
            }
          }
        }

        Post.L.mean[iter-record+1,] <- post.L.mean
        Post.L.sd[iter-record+1,] <- post.L.sd
        Mu.g[iter-record+1,] <- mu.g
        Sigma.g[iter-record+1,] <- sigma.g
        for (k.sub.i in unique(k.sub)) {
          Community[k.sub==k.sub.i,k.sub==k.sub.i] <- Community[k.sub==k.sub.i,k.sub==k.sub.i]+1
        }
        if(length(names(table(k.sub))[table(k.sub)==1])>0){
          Is.singleton[which(k.sub%in%names(table(k.sub))[table(k.sub)==1])] <- Is.singleton[which(k.sub%in%names(table(k.sub))[table(k.sub)==1])]+1
        }
        # Adj <- matrix(data = 0,nrow = length(unique(IDs$SUB_PATHWAY)),ncol = length(unique(IDs$SUB_PATHWAY)))
        # for (k.sub.i in unique(k.sub)) {
        #   Community[k.sub==k.sub.i,k.sub==k.sub.i] <- Community[k.sub==k.sub.i,k.sub==k.sub.i]+1
        #   Adj[k.sub==k.sub.i,k.sub==k.sub.i] <- 1
        # }
        # clusterAssignments[,,iter-record+1] <- Adj

        lfsr <- matrixStats::rowMins(cbind(pnorm(q = 0,mean = post.L.mean,sd = post.L.sd) ,1-pnorm(q = 0,mean = post.L.mean,sd = post.L.sd) ))
        lfsr[post.L.sd==0] <- 1
        LFSR[iter-record+1,] <- lfsr
      }
    }

    #name results
    subpathways <- unlist(sapply(1:length(pathways), function(j){ sapply(1:length(pathways[[j]]), function(g){ pathways[[j]][[g]]$Subpathway }) }))
    metabolites <- IDs$metabolite[unlist(sapply(1:length(pathways), function(j){ sapply(1:length(pathways[[j]]), function(g){ pathways[[j]][[g]]$indices  }) }))]

    #similarity matrix
    w <- Community/(Iter-record+1);colnames(w) <- subpathways;rownames(w)<- subpathways
    p.is.singleton <- Is.singleton/(Iter-record+1)

    colnames(Mu.g) <- subpathways;colnames(Sigma.g) <- subpathways
    colnames(Post.L.mean) <- metabolites;colnames(Post.L.sd) <- metabolites;colnames(LFSR) <- metabolites

    result <- list(Mu.g,Sigma.g,Is.outlier[record:Iter,],Post.L.mean,Post.L.sd,LFSR,w,p.is.singleton,P.post.theta)
    names(result) <- c("Mean","SD","Outlier","L.post.mean","L.post.sd","lfsr","W","p.singleton","P.post.theta")
    Results[[k.latent]] <- result
  }
  names(Results) <- paste0("L",c(1:K))
  return(Results)
}

